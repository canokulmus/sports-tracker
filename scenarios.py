import socket
import threading
import time
import json
import sys
import queue

HOST = '127.0.0.1'
PORT = 8888

# Global dictionary to store dynamic IDs generated by the server.
SHARED_CONTEXT = {}


class TestClient(threading.Thread):
    def __init__(self, name, actions):
        super().__init__()
        self.name = name
        self.actions = actions
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.running = True
        # Queue to pass command responses from the listener thread to the main runner thread
        self.response_queue = queue.Queue()

    def run(self):
        try:
            self.sock.connect((HOST, PORT))
            print(f"[{self.name}] Connected.")

            # Background listener for notifications and responses
            listener = threading.Thread(target=self.listen, daemon=True)
            listener.start()

            for action in self.actions:
                if "wait" in action:
                    print(f"[{self.name}] Sleeping {action['wait']}s...")
                    time.sleep(action['wait'])
                    continue

                # Prepare the payload
                raw_payload = action['payload']
                payload = self.resolve_placeholders(raw_payload)

                print(f"[{self.name}] >> {payload['command']}")
                msg = json.dumps(payload) + "\n"
                self.sock.sendall(msg.encode('utf-8'))

                # Wait for response (Synchronous commands only)
                try:
                    # Critical: Always wait for a response to keep sync
                    response = self.response_queue.get(timeout=5)

                    # Save IDs if requested by the scenario action
                    if "save_id" in action:
                        if response.get("status") == "OK" and "id" in response:
                            saved_key = action["save_id"]
                            new_id = response["id"]
                            SHARED_CONTEXT[saved_key] = new_id
                            print(f"   ðŸ’¾ [{self.name}] Saved ID {new_id} as '${saved_key}'")
                        else:
                            print(f"   âš ï¸ [{self.name}] Failed to save ID: {response}")

                except queue.Empty:
                    print(f"   âŒ [{self.name}] Timeout waiting for response.")

                # Small delay to prevent packet fusion in simple tests (skipped in stress tests)
                if self.name != "Spammer":
                    time.sleep(0.1)

            # Stay alive briefly to catch final notifications
            time.sleep(2)
            self.running = False
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
            except:
                pass
            self.sock.close()

        except Exception as e:
            print(f"[{self.name}] Error: {e}")

    def listen(self):
        """Listens for messages and prints them VERBOSELY."""
        sock_file = self.sock.makefile('r', encoding='utf-8')
        while self.running:
            try:
                line = sock_file.readline()
                if not line: break
                data = json.loads(line)

                # --- VERBOSE PRINTING LOGIC ---
                if data.get("type") == "NOTIFICATION":
                    s = data.get("score", {})
                    # CHANGED: Explicitly print the score so we can verify the test result
                    print(f"   ðŸ”” [{self.name}] NOTIFIED: Game {data.get('game_id')} | "
                          f"State: {data.get('state')} | "
                          f"Score: {s.get('home')} - {s.get('away')}")

                elif data.get("type") == "INFO":
                    print(f"   â„¹ï¸ [{self.name}] INFO: {data.get('message')}")

                else:
                    # Command Response handling
                    if data.get("status") == "OK":
                        if "standings" in data:
                            print(f"   âœ… [{self.name}] Standings Received")
                        else:
                            print(f"   âœ… [{self.name}] Success: {data.get('message')}")
                    elif data.get("status") == "ERROR":
                        print(f"   âŒ [{self.name}] Error: {data.get('message')}")

                    self.response_queue.put(data)

            except ValueError:
                continue
            except Exception:
                break

    def resolve_placeholders(self, payload):
        """Recursively replace string values starting with '$' with values from SHARED_CONTEXT."""
        if isinstance(payload, dict):
            return {k: self.resolve_placeholders(v) for k, v in payload.items()}
        elif isinstance(payload, list):
            return [self.resolve_placeholders(i) for i in payload]
        elif isinstance(payload, str) and payload.startswith("$"):
            key = payload[1:]
            return SHARED_CONTEXT.get(key, payload)
        else:
            return payload


# --- SCENARIO 1: AGGRESSIVE CONCURRENCY ---
def run_concurrency_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 1: AGGRESSIVE CONCURRENCY & RACE CONDITIONS")
    print("Testing: 3 Writers (spamming scores) + 4 Watchers simultaneously.")
    print("Target: Ensure thread safety (RLock) prevents lost updates.")
    print("=" * 60 + "\n")

    # 1. Setup (Single Threaded)
    print("[1/4] Setting up Game Environment...")
    setup_actions = [
        {"payload": {"command": "USER", "username": "Admin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Red Team"}, "save_id": "c_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "Blue Team"}, "save_id": "c_t2"},
        {"payload": {"command": "CREATE_GAME", "home_id": "$c_t1", "away_id": "$c_t2"}, "save_id": "race_game"},
        {"payload": {"command": "START", "id": "$race_game"}}
    ]

    setup_client = TestClient("SetupAdmin", setup_actions)
    setup_client.start()
    setup_client.join()

    # 2. Prepare The Swarm
    # CHANGED: Reduced counts to lower log volume
    NUM_WRITERS = 3
    SCORES_PER_WRITER = 10
    TOTAL_EXPECTED_SCORE = NUM_WRITERS * SCORES_PER_WRITER

    print(f"[2/4] Preparing {NUM_WRITERS} writers x {SCORES_PER_WRITER} updates each...")
    print(f"      Expect final score to be exactly: {TOTAL_EXPECTED_SCORE}")

    writers = []
    watchers = []

    # CHANGED: Watcher count reduced to 4
    for i in range(4):
        w_actions = [
            {"payload": {"command": "USER", "username": f"Watcher_{i}"}},
            {"payload": {"command": "WATCH", "id": "$race_game"}},
            {"wait": 3}
        ]
        watchers.append(TestClient(f"Watcher_{i}", w_actions))

    # Create Writers (Active load - NO WAITS to maximize contention)
    for i in range(NUM_WRITERS):
        side = "HOME" if i % 2 == 0 else "AWAY"
        spam_actions = [{"payload": {"command": "USER", "username": f"Spammer_{i}"}}]
        # CHANGED: Loop runs 10 times instead of 50
        for _ in range(SCORES_PER_WRITER):
            spam_actions.append({
                "payload": {"command": "SCORE", "id": "$race_game", "points": 1, "side": side}
            })
        writers.append(TestClient(f"Writer_{side}_{i}", spam_actions))

    # 3. Launch
    print(f"[3/4] Launching threads...")
    start_time = time.time()

    for w in watchers: w.start()
    for w in writers: w.start()

    for w in writers: w.join()
    for w in watchers: w.join()

    print(f"\n[4/4] Stress test finished in {time.time() - start_time:.2f} seconds.")

    # 4. Verification
    print("      Verifying data integrity...")
    verifier_actions = [
        {"payload": {"command": "USER", "username": "Judge"}},
        {"payload": {"command": "WATCH", "id": "$race_game"}},  # Must Watch first!
        {"payload": {"command": "SCORE", "id": "$race_game", "points": 0, "side": "HOME"}},  # Trigger notification
        {"wait": 2}
    ]

    verifier = TestClient("Verifier", verifier_actions)
    verifier.start()
    verifier.join()

    print("\n" + "-" * 60)
    print(f"Target Score Sum (Home + Away): {TOTAL_EXPECTED_SCORE}")
    print("Check the [Verifier] NOTIFIED message above.")
    print("-" * 60 + "\n")


# --- SCENARIO 2: LEAGUE TOURNAMENT (FULL SEASON) ---
def run_league_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 2: LEAGUE CUP - FULL SEASON SIMULATION")
    print("Testing: Create League -> Fetch Schedule -> Play All Games -> Verify Standings")
    print("=" * 60 + "\n")

    # 1. Setup: Create Teams and the League Cup
    print("[1/3] Initializing League...")
    setup_actions = [
        {"payload": {"command": "USER", "username": "LeagueAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Arsenal"}, "save_id": "t_ars"},
        {"payload": {"command": "CREATE_TEAM", "name": "Liverpool"}, "save_id": "t_liv"},
        {"payload": {"command": "CREATE_TEAM", "name": "Man City"}, "save_id": "t_mci"},
        {"payload": {"command": "CREATE_TEAM", "name": "Chelsea"}, "save_id": "t_che"},

        # Create a LEAGUE cup with these 4 teams
        {"payload": {
            "command": "CREATE_CUP",
            "cup_type": "LEAGUE",
            "team_ids": ["$t_ars", "$t_liv", "$t_mci", "$t_che"]
        }, "save_id": "pl_cup"},
    ]

    t_setup = TestClient("LeagueAdmin", setup_actions)
    t_setup.start()
    t_setup.join()

    # 2. Logic: Fetch the generated game IDs so we can play them
    # We use a raw socket here because we need to extract data dynamically to build the next step
    print("\n[2/3] Fetching Match Schedule from Server...")
    try:
        cup_id = SHARED_CONTEXT["pl_cup"]
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))

        # Send GET_CUP_GAMES command
        req = {"command": "GET_CUP_GAMES", "id": cup_id}
        s.sendall(json.dumps(req).encode('utf-8') + b"\n")

        # Read Welcome Message (ignore)
        s.makefile().readline()
        # Read Response
        response_line = s.makefile().readline()
        response = json.loads(response_line)

        game_ids = response.get("game_ids", [])
        print(f"      League generated {len(game_ids)} games: {game_ids}")
        s.close()
    except Exception as e:
        print(f"      âŒ Failed to fetch games: {e}")
        return

    # 3. Action: Play every game in the season
    print(f"\n[3/3] Simulating the Season ({len(game_ids)} matches)...")

    season_actions = [{"payload": {"command": "USER", "username": "Referee"}}]

    # Observe the cup to see updates for ALL games
    season_actions.append({"payload": {"command": "WATCH", "id": "$pl_cup"}})

    import random
    for gid in game_ids:
        # Generate random realistic scores
        home_score = random.randint(0, 4)
        away_score = random.randint(0, 4)

        season_actions.append({"payload": {"command": "START", "id": gid}})

        # Add scores (simulating the match)
        if home_score > 0:
            season_actions.append({"payload": {"command": "SCORE", "id": gid, "points": home_score, "side": "HOME"}})
        if away_score > 0:
            season_actions.append({"payload": {"command": "SCORE", "id": gid, "points": away_score, "side": "AWAY"}})

        season_actions.append({"payload": {"command": "END", "id": gid}})
        # Small wait between games to make logs readable
        season_actions.append({"wait": 0.2})

    # Finally, get the table
    season_actions.append({"payload": {"command": "GET_STANDINGS", "id": "$pl_cup"}})

    t_season = TestClient("SeasonSim", season_actions)
    t_season.start()
    t_season.join()

    print("\n" + "-" * 60)
    print("SCENARIO COMPLETE. Verify that:")
    print("1. All games were played (Started -> Scored -> Ended).")
    print("2. The final 'standings' printed above show non-zero points.")
    print("-" * 60 + "\n")


# --- SCENARIO 3: ELIMINATION TOURNAMENT ---
def run_elimination_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 3: ELIMINATION CUP")
    print("Testing: Bracket logic over TCP")
    print("=" * 50 + "\n")

    actions = [
        {"payload": {"command": "USER", "username": "ElimAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 1"}, "save_id": "e_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 2"}, "save_id": "e_t2"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 3"}, "save_id": "e_t3"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 4"}, "save_id": "e_t4"},

        {"payload": {"command": "CREATE_CUP", "cup_type": "ELIMINATION",
                     "team_ids": ["$e_t1", "$e_t2", "$e_t3", "$e_t4"]}, "save_id": "elim_id"},
        {"payload": {"command": "GET_STANDINGS", "id": "$elim_id"}}
    ]

    t = TestClient("ElimAdmin", actions)
    t.start();
    t.join()


# --- SCENARIO 4: GROUP STAGE TRANSITION ---
def run_group_transition_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 4: GROUP TO PLAYOFF TRANSITION")
    print("Testing: Playing all group games and triggering playoffs.")
    print("=" * 50 + "\n")

    # 1. Setup: Create 8 teams (Enough for 4 groups of 2)
    setup_actions = [{"payload": {"command": "USER", "username": "GroupAdmin"}}]

    team_ids = []
    # Create 8 teams so we get 2 teams per group (4 groups default) -> 1 game per group
    for i in range(1, 9):
        t_id = f"g_t{i}"
        setup_actions.append({
            "payload": {"command": "CREATE_TEAM", "name": f"G-Team {i}"},
            "save_id": t_id
        })
        team_ids.append(f"${t_id}")

    setup_actions.append({
        "payload": {"command": "CREATE_CUP", "cup_type": "GROUP", "team_ids": team_ids},
        "save_id": "group_cup"
    })

    # Run setup
    client = TestClient("Setup", setup_actions)
    client.start()
    client.join()

    # 2. Dynamic Play: Fetch games and play them all
    print("[Logic] Fetching group games to simulate matches...")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    s.sendall(json.dumps({"command": "GET_CUP_GAMES", "id": SHARED_CONTEXT["group_cup"]}).encode() + b"\n")
    s.makefile().readline()  # Skip info
    resp = json.loads(s.makefile().readline())
    game_ids = resp.get("game_ids", [])
    s.close()

    print(f"[Logic] Found {len(game_ids)} group games. Playing them now...")

    play_actions = [{"payload": {"command": "USER", "username": "Referee"}}]
    for gid in game_ids:
        play_actions.append({"payload": {"command": "START", "id": gid}})
        play_actions.append({"payload": {"command": "SCORE", "id": gid, "points": 3, "side": "HOME"}})
        # We rely on the internal logic that the game is 'played' enough for standings

    # 3. Trigger Playoffs
    play_actions.append({"wait": 1})
    play_actions.append({"payload": {"command": "GENERATE_PLAYOFFS", "id": "$group_cup"}})

    player = TestClient("Referee", play_actions)
    player.start()
    player.join()


# --- SCENARIO 5: PERSISTENCE CHECK ---
def run_persistence_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 5: PERSISTENCE & RECOVERY")
    print("Testing: Save state, (Simulated) Restart, Verify Data.")
    print("=" * 50 + "\n")

    # Step 1: Create Data (Teams AND a Game) and Save
    seed_actions = [
        {"payload": {"command": "USER", "username": "Saver"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Persistent FC"}, "save_id": "p_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "Immutable Utd"}, "save_id": "p_t2"},
        # Create a Game, because Games are watchable
        {"payload": {"command": "CREATE_GAME", "home_id": "$p_t1", "away_id": "$p_t2"}, "save_id": "p_game"},
        {"payload": {"command": "SAVE"}}
    ]

    c1 = TestClient("Saver", seed_actions)
    c1.start()
    c1.join()

    print("\n   âš ï¸  ACTION REQUIRED: Restart the Server NOW to test persistence.")
    print("   âš ï¸  (Stop 'server.py', then run it again)")

    # --- FIX: Use input to wait indefinitely ---
    input("   âš ï¸  Press ENTER here once the server is back online >> ")

    # Step 2: Connect and Verify
    verify_actions = [
        {"payload": {"command": "USER", "username": "Verifier"}},
        {"payload": {"command": "WATCH", "id": "$p_game"}}
    ]

    c2 = TestClient("Verifier", verify_actions)
    c2.start()
    c2.join()

if __name__ == "__main__":
    run_concurrency_scenario()
    time.sleep(1)
    run_league_scenario()
    time.sleep(1)
    run_elimination_scenario()
    time.sleep(1)
    run_group_transition_scenario()
    time.sleep(1)
    run_persistence_scenario()
