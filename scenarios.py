import socket
import threading
import time
import json
import sys
import queue

HOST = '127.0.0.1'
PORT = 8888

# Global dictionary to store dynamic IDs generated by the server.
SHARED_CONTEXT = {}


class TestClient(threading.Thread):
    def __init__(self, name, actions):
        super().__init__()
        self.name = name
        self.actions = actions
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.running = True
        # Queue to pass command responses from the listener thread to the main runner thread
        self.response_queue = queue.Queue()

    def run(self):
        try:
            self.sock.connect((HOST, PORT))
            print(f"[{self.name}] Connected.")

            # Background listener for notifications and responses
            listener = threading.Thread(target=self.listen, daemon=True)
            listener.start()

            for action in self.actions:
                if "wait" in action:
                    print(f"[{self.name}] Sleeping {action['wait']}s...")
                    time.sleep(action['wait'])
                    continue

                # Prepare the payload
                raw_payload = action['payload']
                payload = self.resolve_placeholders(raw_payload)

                print(f"[{self.name}] >> {payload['command']}")
                msg = json.dumps(payload) + "\n"
                self.sock.sendall(msg.encode('utf-8'))

                # Wait for response (Synchronous commands only)
                try:
                    # Critical: Always wait for a response to keep sync
                    response = self.response_queue.get(timeout=5)

                    # Save IDs if requested by the scenario action
                    if "save_id" in action:
                        if response.get("status") == "OK" and "id" in response:
                            saved_key = action["save_id"]
                            new_id = response["id"]
                            SHARED_CONTEXT[saved_key] = new_id
                            print(f"   ðŸ’¾ [{self.name}] Saved ID {new_id} as '${saved_key}'")
                        else:
                            print(f"   âš ï¸ [{self.name}] Failed to save ID: {response}")

                except queue.Empty:
                    print(f"   âŒ [{self.name}] Timeout waiting for response.")

                # Small delay to prevent packet fusion in simple tests (skipped in stress tests)
                if self.name != "Spammer":
                    time.sleep(0.1)

            # Stay alive briefly to catch final notifications
            time.sleep(2)
            self.running = False
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
            except:
                pass
            self.sock.close()

        except Exception as e:
            print(f"[{self.name}] Error: {e}")

    def listen(self):
        """Listens for messages and prints them VERBOSELY."""
        sock_file = self.sock.makefile('r', encoding='utf-8')
        while self.running:
            try:
                line = sock_file.readline()
                if not line: break
                data = json.loads(line)

                # --- VERBOSE PRINTING LOGIC ---
                if data.get("type") == "NOTIFICATION":
                    s = data.get("score", {})
                    # CHANGED: Explicitly print the score so we can verify the test result
                    print(f"   ðŸ”” [{self.name}] NOTIFIED: Game {data.get('game_id')} | "
                          f"State: {data.get('state')} | "
                          f"Score: {s.get('home')} - {s.get('away')}")

                elif data.get("type") == "INFO":
                    print(f"   â„¹ï¸ [{self.name}] INFO: {data.get('message')}")

                else:
                    # Command Response handling
                    if data.get("status") == "OK":
                        if "standings" in data:
                            print(f"   âœ… [{self.name}] Standings Received")
                        else:
                            print(f"   âœ… [{self.name}] Success: {data.get('message')}")
                    elif data.get("status") == "ERROR":
                        print(f"   âŒ [{self.name}] Error: {data.get('message')}")

                    self.response_queue.put(data)

            except ValueError:
                continue
            except Exception:
                break

    def resolve_placeholders(self, payload):
        """Recursively replace string values starting with '$' with values from SHARED_CONTEXT."""
        if isinstance(payload, dict):
            return {k: self.resolve_placeholders(v) for k, v in payload.items()}
        elif isinstance(payload, list):
            return [self.resolve_placeholders(i) for i in payload]
        elif isinstance(payload, str) and payload.startswith("$"):
            key = payload[1:]
            return SHARED_CONTEXT.get(key, payload)
        else:
            return payload


# --- SCENARIO 1: AGGRESSIVE CONCURRENCY ---
def run_concurrency_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 1: AGGRESSIVE CONCURRENCY & RACE CONDITIONS")
    print("Testing: 3 Writers (spamming scores) + 4 Watchers simultaneously.")
    print("Target: Ensure thread safety (RLock) prevents lost updates.")
    print("=" * 60 + "\n")

    # 1. Setup (Single Threaded)
    print("[1/4] Setting up Game Environment...")
    setup_actions = [
        {"payload": {"command": "USER", "username": "Admin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Red Team"}, "save_id": "c_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "Blue Team"}, "save_id": "c_t2"},
        {"payload": {"command": "CREATE_GAME", "home_id": "$c_t1", "away_id": "$c_t2"}, "save_id": "race_game"},
        {"payload": {"command": "START", "id": "$race_game"}}
    ]

    setup_client = TestClient("SetupAdmin", setup_actions)
    setup_client.start()
    setup_client.join()

    # 2. Prepare The Swarm
    # CHANGED: Reduced counts to lower log volume
    NUM_WRITERS = 3
    SCORES_PER_WRITER = 10
    TOTAL_EXPECTED_SCORE = NUM_WRITERS * SCORES_PER_WRITER

    print(f"[2/4] Preparing {NUM_WRITERS} writers x {SCORES_PER_WRITER} updates each...")
    print(f"      Expect final score to be exactly: {TOTAL_EXPECTED_SCORE}")

    writers = []
    watchers = []

    # CHANGED: Watcher count reduced to 4
    for i in range(4):
        w_actions = [
            {"payload": {"command": "USER", "username": f"Watcher_{i}"}},
            {"payload": {"command": "WATCH", "id": "$race_game"}},
            {"wait": 3}
        ]
        watchers.append(TestClient(f"Watcher_{i}", w_actions))

    # Create Writers (Active load - NO WAITS to maximize contention)
    for i in range(NUM_WRITERS):
        side = "HOME" if i % 2 == 0 else "AWAY"
        spam_actions = [{"payload": {"command": "USER", "username": f"Spammer_{i}"}}]
        # CHANGED: Loop runs 10 times instead of 50
        for _ in range(SCORES_PER_WRITER):
            spam_actions.append({
                "payload": {"command": "SCORE", "id": "$race_game", "points": 1, "side": side}
            })
        writers.append(TestClient(f"Writer_{side}_{i}", spam_actions))

    # 3. Launch
    print(f"[3/4] Launching threads...")
    start_time = time.time()

    for w in watchers: w.start()
    for w in writers: w.start()

    for w in writers: w.join()
    for w in watchers: w.join()

    print(f"\n[4/4] Stress test finished in {time.time() - start_time:.2f} seconds.")

    # 4. Verification
    print("      Verifying data integrity...")
    verifier_actions = [
        {"payload": {"command": "USER", "username": "Judge"}},
        {"payload": {"command": "WATCH", "id": "$race_game"}},  # Must Watch first!
        {"payload": {"command": "SCORE", "id": "$race_game", "points": 0, "side": "HOME"}},  # Trigger notification
        {"wait": 2}
    ]

    verifier = TestClient("Verifier", verifier_actions)
    verifier.start()
    verifier.join()

    print("\n" + "-" * 60)
    print(f"Target Score Sum (Home + Away): {TOTAL_EXPECTED_SCORE}")
    print("Check the [Verifier] NOTIFIED message above.")
    print("-" * 60 + "\n")


# --- SCENARIO 2: LEAGUE TOURNAMENT (FULL SEASON) ---
def run_league_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 2: LEAGUE CUP - FULL SEASON SIMULATION")
    print("Testing: Create League -> Fetch Schedule -> Play All Games -> Verify Standings")
    print("=" * 60 + "\n")

    # 1. Setup: Create Teams and the League Cup
    print("[1/3] Initializing League...")
    setup_actions = [
        {"payload": {"command": "USER", "username": "LeagueAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Arsenal"}, "save_id": "t_ars"},
        {"payload": {"command": "CREATE_TEAM", "name": "Liverpool"}, "save_id": "t_liv"},
        {"payload": {"command": "CREATE_TEAM", "name": "Man City"}, "save_id": "t_mci"},
        {"payload": {"command": "CREATE_TEAM", "name": "Chelsea"}, "save_id": "t_che"},

        # Create a LEAGUE cup with these 4 teams
        {"payload": {
            "command": "CREATE_CUP",
            "cup_type": "LEAGUE",
            "team_ids": ["$t_ars", "$t_liv", "$t_mci", "$t_che"]
        }, "save_id": "pl_cup"},
    ]

    t_setup = TestClient("LeagueAdmin", setup_actions)
    t_setup.start()
    t_setup.join()

    # 2. Logic: Fetch the generated game IDs so we can play them
    # We use a raw socket here because we need to extract data dynamically to build the next step
    print("\n[2/3] Fetching Match Schedule from Server...")
    try:
        cup_id = SHARED_CONTEXT["pl_cup"]
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))

        # Send GET_CUP_GAMES command
        req = {"command": "GET_CUP_GAMES", "id": cup_id}
        s.sendall(json.dumps(req).encode('utf-8') + b"\n")

        # Read Welcome Message (ignore)
        s.makefile().readline()
        # Read Response
        response_line = s.makefile().readline()
        response = json.loads(response_line)

        game_ids = response.get("game_ids", [])
        print(f"      League generated {len(game_ids)} games: {game_ids}")
        s.close()
    except Exception as e:
        print(f"      âŒ Failed to fetch games: {e}")
        return

    # 3. Action: Play every game in the season
    print(f"\n[3/3] Simulating the Season ({len(game_ids)} matches)...")

    season_actions = [{"payload": {"command": "USER", "username": "Referee"}}]

    # Observe the cup to see updates for ALL games
    season_actions.append({"payload": {"command": "WATCH", "id": "$pl_cup"}})

    import random
    for gid in game_ids:
        # Generate random realistic scores
        home_score = random.randint(0, 4)
        away_score = random.randint(0, 4)

        season_actions.append({"payload": {"command": "START", "id": gid}})

        # Add scores (simulating the match)
        if home_score > 0:
            season_actions.append({"payload": {"command": "SCORE", "id": gid, "points": home_score, "side": "HOME"}})
        if away_score > 0:
            season_actions.append({"payload": {"command": "SCORE", "id": gid, "points": away_score, "side": "AWAY"}})

        season_actions.append({"payload": {"command": "END", "id": gid}})
        # Small wait between games to make logs readable
        season_actions.append({"wait": 0.2})

    # Finally, get the table
    season_actions.append({"payload": {"command": "GET_STANDINGS", "id": "$pl_cup"}})

    t_season = TestClient("SeasonSim", season_actions)
    t_season.start()
    t_season.join()

    print("\n" + "-" * 60)
    print("SCENARIO COMPLETE. Verify that:")
    print("1. All games were played (Started -> Scored -> Ended).")
    print("2. The final 'standings' printed above show non-zero points.")
    print("-" * 60 + "\n")


# --- SCENARIO 3: ELIMINATION TOURNAMENT (KNOCKOUT) ---
def run_elimination_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 3: ELIMINATION CUP - KNOCKOUT SIMULATION")
    print("Testing: Create 8-Team Bracket -> Play QF/SF/Finals -> Verify Champion")
    print("=" * 60 + "\n")

    # 1. Setup: Create 8 Teams for a standard Quarter-Final start
    print("[1/3] Initializing Elimination Tournament...")
    setup_actions = [{"payload": {"command": "USER", "username": "ElimAdmin"}}]

    team_ids = []
    # Create 8 teams (E-Team 1 to E-Team 8)
    for i in range(1, 9):
        tid = f"e_t{i}"
        setup_actions.append({
            "payload": {"command": "CREATE_TEAM", "name": f"E-Team {i}"},
            "save_id": tid
        })
        team_ids.append(f"${tid}")

    setup_actions.append({
        "payload": {"command": "CREATE_CUP", "cup_type": "ELIMINATION", "team_ids": team_ids},
        "save_id": "elim_id"
    })

    t_setup = TestClient("ElimAdmin", setup_actions)
    t_setup.start()
    t_setup.join()

    # 2. Logic: Fetch the bracket games
    print("\n[2/3] Fetching Bracket...")
    try:
        cup_id = SHARED_CONTEXT["elim_id"]
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))
        s.sendall(json.dumps({"command": "GET_CUP_GAMES", "id": cup_id}).encode('utf-8') + b"\n")
        s.makefile().readline()  # Skip info
        response = json.loads(s.makefile().readline())
        game_ids = response.get("game_ids", [])
        print(f"      Bracket generated {len(game_ids)} games: {game_ids}")
        s.close()
    except Exception as e:
        print(f"      âŒ Failed to fetch bracket: {e}")
        return

    # 3. Action: Play the Knockout Stages
    print(f"\n[3/3] Simulating Knockout Stages...")

    # We play games in ID order. In a generated bracket,
    # IDs usually follow the flow (QF -> Semis -> Final) or creation order.
    # We'll play all of them.

    knockout_actions = [{"payload": {"command": "USER", "username": "Umpire"}}]
    knockout_actions.append({"payload": {"command": "WATCH", "id": "$elim_id"}})

    import random
    for i, gid in enumerate(game_ids):
        # Determine round based on game index (for 8 teams: 0-3=QF, 4-5=SF, 6=Final)
        if i < 4:
            stage = "Quarter-Final"
        elif i < 6:
            stage = "Semi-Final"
        else:
            stage = "GRAND FINAL"

        knockout_actions.append({"wait": 0.1})
        knockout_actions.append({"payload": {"command": "START", "id": gid}})

        # Decide a winner (High score vs Low score)
        # We force a winner to avoid draws in elimination
        winner_score = random.randint(3, 5)
        loser_score = random.randint(0, 2)

        knockout_actions.append({"payload": {"command": "SCORE", "id": gid, "points": winner_score, "side": "HOME"}})
        knockout_actions.append({"payload": {"command": "SCORE", "id": gid, "points": loser_score, "side": "AWAY"}})
        knockout_actions.append({"payload": {"command": "END", "id": gid}})

    # Get final bracket results
    knockout_actions.append({"payload": {"command": "GET_STANDINGS", "id": "$elim_id"}})

    t_ko = TestClient("KnockoutSim", knockout_actions)
    t_ko.start()
    t_ko.join()

    print("\n" + "-" * 60)
    print("SCENARIO COMPLETE. Verify that:")
    print(f"1. All {len(game_ids)} games were played.")
    print("2. Notifications show progression (QF -> Semi -> Final).")
    print("3. Standings above show a team reaching 'Round 3' (The Champion).")
    print("-" * 60 + "\n")


# --- SCENARIO 4: GROUP STAGE TRANSITION & PLAYOFFS ---
def run_group_transition_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 4: GROUP TO PLAYOFF TRANSITION")
    print("Testing: Group Stage -> Standings -> Playoff Generation -> Knockout Phase")
    print("=" * 60 + "\n")

    # 1. Setup: Create 8 teams (2 teams per group with default 4 groups)
    print("[1/4] Initializing Group Tournament...")
    setup_actions = [{"payload": {"command": "USER", "username": "GroupAdmin"}}]

    team_ids = []
    # Creating 8 teams ensures we have populated groups (Teams A-H)
    for i in range(1, 9):
        t_id = f"g_t{i}"
        setup_actions.append({
            "payload": {"command": "CREATE_TEAM", "name": f"Nation-{i}"},
            "save_id": t_id
        })
        team_ids.append(f"${t_id}")

    setup_actions.append({
        "payload": {"command": "CREATE_CUP", "cup_type": "GROUP", "team_ids": team_ids},
        "save_id": "group_cup"
    })

    t_setup = TestClient("Setup", setup_actions)
    t_setup.start()
    t_setup.join()

    # 2. Logic: Fetch Group Games
    print("\n[2/4] Fetching Group Stage Schedule...")
    group_game_ids = []
    try:
        cup_id = SHARED_CONTEXT["group_cup"]
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))
        s.sendall(json.dumps({"command": "GET_CUP_GAMES", "id": cup_id}).encode('utf-8') + b"\n")
        s.makefile().readline()
        resp = json.loads(s.makefile().readline())
        group_game_ids = resp.get("game_ids", [])
        s.close()
        print(f"      Found {len(group_game_ids)} group games to play.")
    except Exception as e:
        print(f"      âŒ Critical Error fetching games: {e}")
        return

    # 3. Play Group Stage
    print(f"\n[3/4] Simulating Group Stage ({len(group_game_ids)} matches)...")

    group_play_actions = [{"payload": {"command": "USER", "username": "Referee"}}]
    # Watch to see the live updates
    group_play_actions.append({"payload": {"command": "WATCH", "id": "$group_cup"}})

    import random
    for gid in group_game_ids:
        # Random scores to create a mix of wins/losses/draws
        s1 = random.randint(0, 3)
        s2 = random.randint(0, 3)

        group_play_actions.append({"payload": {"command": "START", "id": gid}})
        if s1 > 0:
            group_play_actions.append({"payload": {"command": "SCORE", "id": gid, "points": s1, "side": "HOME"}})
        if s2 > 0:
            group_play_actions.append({"payload": {"command": "SCORE", "id": gid, "points": s2, "side": "AWAY"}})
        group_play_actions.append({"payload": {"command": "END", "id": gid}})
        # Tiny sleep to ensure logs don't overlap too much
        group_play_actions.append({"wait": 0.1})

    t_group_play = TestClient("GroupStage", group_play_actions)
    t_group_play.start()
    t_group_play.join()

    # 4. Trigger Playoffs and Play Them
    print("\n[4/4] Generating & Playing Playoffs...")

    # We use a raw socket query again to compare game counts before/after
    # This proves the server actually created new game objects
    playoff_actions = [
        {"payload": {"command": "USER", "username": "TournamentDirector"}},
        {"payload": {"command": "GENERATE_PLAYOFFS", "id": "$group_cup"}}
    ]

    t_gen = TestClient("Director", playoff_actions)
    t_gen.start()
    t_gen.join()

    # Fetch the NEW list of games
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))
        s.sendall(json.dumps({"command": "GET_CUP_GAMES", "id": cup_id}).encode('utf-8') + b"\n")
        s.makefile().readline()
        resp = json.loads(s.makefile().readline())
        all_game_ids = resp.get("game_ids", [])
        s.close()

        # Filter out the group games we already played
        playoff_game_ids = [gid for gid in all_game_ids if gid not in group_game_ids]
        print(f"      ðŸ† Playoffs Generated! {len(playoff_game_ids)} new knockout games created.")
    except Exception:
        playoff_game_ids = []

    # Simulate the Playoff Matches
    if playoff_game_ids:
        finals_actions = [{"payload": {"command": "USER", "username": "FinalsRef"}}]
        for gid in playoff_game_ids:
            finals_actions.append({"payload": {"command": "START", "id": gid}})
            # High stakes scoring!
            finals_actions.append(
                {"payload": {"command": "SCORE", "id": gid, "points": random.randint(1, 5), "side": "HOME"}})
            finals_actions.append({"payload": {"command": "END", "id": gid}})
            finals_actions.append({"wait": 0.1})

        t_finals = TestClient("Playoffs", finals_actions)
        t_finals.start()
        t_finals.join()

    print("\n" + "-" * 60)
    print("SCENARIO COMPLETE. Success Criteria:")
    print("1. Group games played -> Scores updated -> Games Ended.")
    print("2. 'Playoffs Generated' message appeared with new game count.")
    print("3. Playoff games (Winner of X vs Winner of Y) were played.")
    print("-" * 60 + "\n")


# --- SCENARIO 5: PERSISTENCE & RECOVERY ---
def run_persistence_scenario():
    print("\n" + "=" * 60)
    print("SCENARIO 5: PERSISTENCE & RECOVERY")
    print("Testing: Save Running Game -> Restart Server -> Verify Score/State Preserved")
    print("=" * 60 + "\n")

    # 1. Seed Data: Create a game, START it, and SCORE points
    print("[1/2] Seeding Data (Creating & Modifying State)...")
    seed_actions = [
        {"payload": {"command": "USER", "username": "Saver"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Legends FC"}, "save_id": "p_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "Mythic Utd"}, "save_id": "p_t2"},
        {"payload": {"command": "CREATE_GAME", "home_id": "$p_t1", "away_id": "$p_t2"}, "save_id": "p_game"},

        # Modify state so we verify more than just existence
        {"payload": {"command": "START", "id": "$p_game"}},
        {"payload": {"command": "SCORE", "id": "$p_game", "points": 10, "side": "HOME"}},
        {"payload": {"command": "SCORE", "id": "$p_game", "points": 5, "side": "AWAY"}},

        # Save to disk
        {"payload": {"command": "SAVE"}}
    ]

    c1 = TestClient("Saver", seed_actions)
    c1.start()
    c1.join()

    print("\n" + "!" * 60)
    print("   ACTION REQUIRED: Restart the Server NOW.")
    print("   1. Stop 'server.py' (Ctrl+C)")
    print("   2. Run 'python server.py' again")
    print("   3. Come back here and press ENTER")
    print("!" * 60)
    input("   >> Press ENTER once Server is back online: ")

    # 2. Verify Data: Connect and check if the score is 10-5
    print("\n[2/2] Verifying Persistence...")
    verify_actions = [
        {"payload": {"command": "USER", "username": "Verifier"}},
        # Watch triggers a notification if we modify state, or we can just infer from a new score
        {"payload": {"command": "WATCH", "id": "$p_game"}},

        # Score 0 to trigger a notification with the CURRENT total score
        {"payload": {"command": "SCORE", "id": "$p_game", "points": 0, "side": "HOME"}},
        {"wait": 2}
    ]

    c2 = TestClient("Verifier", verify_actions)
    c2.start()
    c2.join()

    print("\n" + "-" * 60)
    print("SCENARIO COMPLETE. Verification:")
    print("1. Look at the [Verifier] notification above.")
    print("2. Did it show 'Legends FC' vs 'Mythic Utd'?")
    print("3. Was the score 10 - 5? (If it's 0-0, persistence failed).")
    print("-" * 60 + "\n")


if __name__ == "__main__":
    run_concurrency_scenario()
    time.sleep(1)
    run_league_scenario()
    time.sleep(1)
    run_elimination_scenario()
    time.sleep(1)
    run_group_transition_scenario()
    time.sleep(1)
    run_persistence_scenario()
