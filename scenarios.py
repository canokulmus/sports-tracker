import socket
import threading
import time
import json
import sys
import queue

HOST = '127.0.0.1'
PORT = 8888

# Global dictionary to store dynamic IDs generated by the server.
SHARED_CONTEXT = {}


class TestClient(threading.Thread):
    def __init__(self, name, actions):
        super().__init__()
        self.name = name
        self.actions = actions
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.running = True
        # Queue to pass command responses from the listener thread to the main runner thread
        self.response_queue = queue.Queue()

    def run(self):
        try:
            self.sock.connect((HOST, PORT))
            print(f"[{self.name}] Connected.")

            # Background listener for notifications and responses
            listener = threading.Thread(target=self.listen, daemon=True)
            listener.start()

            for action in self.actions:
                if "wait" in action:
                    print(f"[{self.name}] Sleeping {action['wait']}s...")
                    time.sleep(action['wait'])
                    continue

                # Prepare the payload
                raw_payload = action['payload']

                # Dynamic ID Resolution: Replace placeholders (e.g., "$team_a") with actual IDs from context
                payload = self.resolve_placeholders(raw_payload)

                print(f"[{self.name}] >> {payload['command']}")
                msg = json.dumps(payload) + "\n"
                self.sock.sendall(msg.encode('utf-8'))

                # --- CRITICAL FIX: ALWAYS WAIT FOR RESPONSE ---
                # The server sends a response for every command (USER, CREATE, etc.).
                # We must consume it to keep the queue synchronized, even if we don't save an ID.
                try:
                    response = self.response_queue.get(timeout=5)

                    # If this action expects to save a resulting ID
                    if "save_id" in action:
                        if response.get("status") == "OK" and "id" in response:
                            saved_key = action["save_id"]
                            new_id = response["id"]
                            SHARED_CONTEXT[saved_key] = new_id
                            print(f"   üíæ [{self.name}] Saved ID {new_id} as '${saved_key}'")
                        else:
                            print(f"   ‚ö†Ô∏è [{self.name}] Failed to save ID from response: {response}")

                except queue.Empty:
                    print(f"   ‚ùå [{self.name}] Timeout waiting for response.")

                time.sleep(0.2)  # Small delay to ensure order

            # Stay alive briefly to catch final notifications
            time.sleep(2)
            self.running = False
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
            except:
                pass
            self.sock.close()

        except Exception as e:
            print(f"[{self.name}] Error: {e}")

    def listen(self):
        sock_file = self.sock.makefile('r', encoding='utf-8')
        while self.running:
            try:
                line = sock_file.readline()
                if not line: break
                data = json.loads(line)

                # Differentiate between Async Notifications and Command Responses
                if data.get("type") == "NOTIFICATION":
                    print(f"   üîî [{self.name}] NOTIFIED: Game {data.get('game_id')} state={data.get('state')}")

                elif data.get("type") == "INFO":
                    # Welcome messages do not correspond to a specific command sent by run(), so we handle them here.
                    print(f"   ‚ÑπÔ∏è [{self.name}] INFO: {data.get('message')}")

                else:
                    # This is a synchronous response to a command (status: OK/ERROR)
                    if data.get("status") == "OK":
                        # If we have standings, print them instead of "None"
                        if "standings" in data:
                            print(f"   ‚úÖ [{self.name}] Success: Retrieved Standings")
                            # Optional: Print the actual data if you want to see it
                            # print(json.dumps(data["standings"], indent=3))
                        else:
                            print(f"   ‚úÖ [{self.name}] Success: {data.get('message')}")
                    elif data.get("status") == "ERROR":
                        print(f"   ‚ùå [{self.name}] Error: {data.get('message')}")

                    self.response_queue.put(data)

            except ValueError:
                continue
            except Exception:
                break

    def resolve_placeholders(self, payload):
        """Recursively replace string values starting with '$' with values from SHARED_CONTEXT."""
        if isinstance(payload, dict):
            return {k: self.resolve_placeholders(v) for k, v in payload.items()}
        elif isinstance(payload, list):
            return [self.resolve_placeholders(i) for i in payload]
        elif isinstance(payload, str) and payload.startswith("$"):
            key = payload[1:]
            if key in SHARED_CONTEXT:
                return SHARED_CONTEXT[key]
            else:
                # Keep the placeholder if not found, to make the error obvious in the server logs
                return payload
        else:
            return payload


# --- SCENARIO 1: CONCURRENCY ---
def run_concurrency_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 1: CONCURRENCY & OBSERVERS")
    print("Testing: 2 Watchers, 1 Updater interacting simultaneously.")
    print("=" * 50 + "\n")

    # 1. Admin creates a game and saves the IDs
    admin_actions = [
        {"payload": {"command": "USER", "username": "Admin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Team A"}, "save_id": "team_a"},
        {"payload": {"command": "CREATE_TEAM", "name": "Team B"}, "save_id": "team_b"},
        {"payload": {"command": "CREATE_GAME", "home_id": "$team_a", "away_id": "$team_b"}, "save_id": "conc_game"}
    ]

    # 2. Watcher 1 (Alice)
    alice_actions = [
        {"payload": {"command": "USER", "username": "Alice"}},
        {"wait": 2},
        {"payload": {"command": "WATCH", "id": "$conc_game"}},
        {"wait": 5}
    ]

    # 3. Watcher 2 (Bob)
    bob_actions = [
        {"payload": {"command": "USER", "username": "Bob"}},
        {"wait": 2},
        {"payload": {"command": "WATCH", "id": "$conc_game"}},
        {"wait": 5}
    ]

    # 4. Updater (Charlie)
    charlie_actions = [
        {"payload": {"command": "USER", "username": "Charlie"}},
        {"wait": 3},
        {"payload": {"command": "START", "id": "$conc_game"}},
        {"payload": {"command": "SCORE", "id": "$conc_game", "points": 2, "side": "HOME"}},
        {"payload": {"command": "SCORE", "id": "$conc_game", "points": 3, "side": "AWAY"}},
    ]

    t_admin = TestClient("Admin", admin_actions)
    t_alice = TestClient("Alice", alice_actions)
    t_bob = TestClient("Bob", bob_actions)
    t_charlie = TestClient("Charlie", charlie_actions)

    t_admin.start()
    t_admin.join()

    t_alice.start()
    t_bob.start()
    t_charlie.start()

    t_alice.join()
    t_bob.join()
    t_charlie.join()


# --- SCENARIO 2: LEAGUE TOURNAMENT ---
def run_league_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 2: LEAGUE CUP")
    print("Testing: Create League, Play Game, Check Standings")
    print("=" * 50 + "\n")

    actions = [
        {"payload": {"command": "USER", "username": "LeagueAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 1"}, "save_id": "l_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 2"}, "save_id": "l_t2"},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 3"}, "save_id": "l_t3"},
        {"payload": {"command": "CREATE_CUP", "cup_type": "LEAGUE", "team_ids": ["$l_t1", "$l_t2", "$l_t3"]},
         "save_id": "league_id"},

        {"payload": {"command": "WATCH", "id": "$league_id"}},
        {"payload": {"command": "GET_STANDINGS", "id": "$league_id"}}
    ]

    t = TestClient("LeagueAdmin", actions)
    t.start();
    t.join()


# --- SCENARIO 3: ELIMINATION TOURNAMENT ---
def run_elimination_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 3: ELIMINATION CUP")
    print("Testing: Bracket logic over TCP")
    print("=" * 50 + "\n")

    actions = [
        {"payload": {"command": "USER", "username": "ElimAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 1"}, "save_id": "e_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 2"}, "save_id": "e_t2"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 3"}, "save_id": "e_t3"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 4"}, "save_id": "e_t4"},

        {"payload": {"command": "CREATE_CUP", "cup_type": "ELIMINATION",
                     "team_ids": ["$e_t1", "$e_t2", "$e_t3", "$e_t4"]}, "save_id": "elim_id"},
        {"payload": {"command": "GET_STANDINGS", "id": "$elim_id"}}
    ]

    t = TestClient("ElimAdmin", actions)
    t.start();
    t.join()


if __name__ == "__main__":
    run_concurrency_scenario()
    time.sleep(1)
    run_league_scenario()
    time.sleep(1)
    run_elimination_scenario()
