import socket
import threading
import time
import json
import sys
import queue

HOST = '127.0.0.1'
PORT = 8888

# Global dictionary to store dynamic IDs generated by the server.
SHARED_CONTEXT = {}


class TestClient(threading.Thread):
    def __init__(self, name, actions):
        super().__init__()
        self.name = name
        self.actions = actions
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.running = True
        # Queue to pass command responses from the listener thread to the main runner thread
        self.response_queue = queue.Queue()

    def run(self):
        try:
            self.sock.connect((HOST, PORT))
            print(f"[{self.name}] Connected.")

            # Background listener for notifications and responses
            listener = threading.Thread(target=self.listen, daemon=True)
            listener.start()

            for action in self.actions:
                if "wait" in action:
                    print(f"[{self.name}] Sleeping {action['wait']}s...")
                    time.sleep(action['wait'])
                    continue

                # Prepare the payload
                raw_payload = action['payload']

                # Dynamic ID Resolution: Replace placeholders (e.g., "$team_a") with actual IDs from context
                payload = self.resolve_placeholders(raw_payload)

                print(f"[{self.name}] >> {payload['command']}")
                msg = json.dumps(payload) + "\n"
                self.sock.sendall(msg.encode('utf-8'))

                # --- CRITICAL FIX: ALWAYS WAIT FOR RESPONSE ---
                # The server sends a response for every command (USER, CREATE, etc.).
                # We must consume it to keep the queue synchronized, even if we don't save an ID.
                try:
                    response = self.response_queue.get(timeout=5)

                    # If this action expects to save a resulting ID
                    if "save_id" in action:
                        if response.get("status") == "OK" and "id" in response:
                            saved_key = action["save_id"]
                            new_id = response["id"]
                            SHARED_CONTEXT[saved_key] = new_id
                            print(f"   ðŸ’¾ [{self.name}] Saved ID {new_id} as '${saved_key}'")
                        else:
                            print(f"   âš ï¸ [{self.name}] Failed to save ID from response: {response}")

                except queue.Empty:
                    print(f"   âŒ [{self.name}] Timeout waiting for response.")

                time.sleep(0.2)  # Small delay to ensure order

            # Stay alive briefly to catch final notifications
            time.sleep(2)
            self.running = False
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
            except:
                pass
            self.sock.close()

        except Exception as e:
            print(f"[{self.name}] Error: {e}")

    def listen(self):
        sock_file = self.sock.makefile('r', encoding='utf-8')
        while self.running:
            try:
                line = sock_file.readline()
                if not line: break
                data = json.loads(line)

                # Differentiate between Async Notifications and Command Responses
                if data.get("type") == "NOTIFICATION":
                    print(f"   ðŸ”” [{self.name}] NOTIFIED: Game {data.get('game_id')} state={data.get('state')}")

                elif data.get("type") == "INFO":
                    # Welcome messages do not correspond to a specific command sent by run(), so we handle them here.
                    print(f"   â„¹ï¸ [{self.name}] INFO: {data.get('message')}")

                else:
                    # This is a synchronous response to a command (status: OK/ERROR)
                    if data.get("status") == "OK":
                        # If we have standings, print them instead of "None"
                        if "standings" in data:
                            print(f"   âœ… [{self.name}] Success: Retrieved Standings")
                            # Optional: Print the actual data if you want to see it
                            # print(json.dumps(data["standings"], indent=3))
                        else:
                            print(f"   âœ… [{self.name}] Success: {data.get('message')}")
                    elif data.get("status") == "ERROR":
                        print(f"   âŒ [{self.name}] Error: {data.get('message')}")

                    self.response_queue.put(data)

            except ValueError:
                continue
            except Exception:
                break

    def resolve_placeholders(self, payload):
        """Recursively replace string values starting with '$' with values from SHARED_CONTEXT."""
        if isinstance(payload, dict):
            return {k: self.resolve_placeholders(v) for k, v in payload.items()}
        elif isinstance(payload, list):
            return [self.resolve_placeholders(i) for i in payload]
        elif isinstance(payload, str) and payload.startswith("$"):
            key = payload[1:]
            if key in SHARED_CONTEXT:
                return SHARED_CONTEXT[key]
            else:
                # Keep the placeholder if not found, to make the error obvious in the server logs
                return payload
        else:
            return payload


# --- SCENARIO 1: CONCURRENCY ---
def run_concurrency_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 1: CONCURRENCY & OBSERVERS")
    print("Testing: 2 Watchers, 1 Updater interacting simultaneously.")
    print("=" * 50 + "\n")

    # 1. Admin creates a game and saves the IDs
    admin_actions = [
        {"payload": {"command": "USER", "username": "Admin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Team A"}, "save_id": "team_a"},
        {"payload": {"command": "CREATE_TEAM", "name": "Team B"}, "save_id": "team_b"},
        {"payload": {"command": "CREATE_GAME", "home_id": "$team_a", "away_id": "$team_b"}, "save_id": "conc_game"}
    ]

    # 2. Watcher 1 (Alice)
    alice_actions = [
        {"payload": {"command": "USER", "username": "Alice"}},
        {"wait": 2},
        {"payload": {"command": "WATCH", "id": "$conc_game"}},
        {"wait": 5}
    ]

    # 3. Watcher 2 (Bob)
    bob_actions = [
        {"payload": {"command": "USER", "username": "Bob"}},
        {"wait": 2},
        {"payload": {"command": "WATCH", "id": "$conc_game"}},
        {"wait": 5}
    ]

    # 4. Updater (Charlie)
    charlie_actions = [
        {"payload": {"command": "USER", "username": "Charlie"}},
        {"wait": 3},
        {"payload": {"command": "START", "id": "$conc_game"}},
        {"payload": {"command": "SCORE", "id": "$conc_game", "points": 2, "side": "HOME"}},
        {"payload": {"command": "SCORE", "id": "$conc_game", "points": 3, "side": "AWAY"}},
    ]

    t_admin = TestClient("Admin", admin_actions)
    t_alice = TestClient("Alice", alice_actions)
    t_bob = TestClient("Bob", bob_actions)
    t_charlie = TestClient("Charlie", charlie_actions)

    t_admin.start()
    t_admin.join()

    t_alice.start()
    t_bob.start()
    t_charlie.start()

    t_alice.join()
    t_bob.join()
    t_charlie.join()


# --- SCENARIO 2: LEAGUE TOURNAMENT ---
def run_league_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 2: LEAGUE CUP")
    print("Testing: Create League, Play Game, Check Standings")
    print("=" * 50 + "\n")

    actions = [
        {"payload": {"command": "USER", "username": "LeagueAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 1"}, "save_id": "l_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 2"}, "save_id": "l_t2"},
        {"payload": {"command": "CREATE_TEAM", "name": "L-Team 3"}, "save_id": "l_t3"},
        {"payload": {"command": "CREATE_CUP", "cup_type": "LEAGUE", "team_ids": ["$l_t1", "$l_t2", "$l_t3"]},
         "save_id": "league_id"},

        {"payload": {"command": "WATCH", "id": "$league_id"}},
        {"payload": {"command": "GET_STANDINGS", "id": "$league_id"}}
    ]

    t = TestClient("LeagueAdmin", actions)
    t.start();
    t.join()


# --- SCENARIO 3: ELIMINATION TOURNAMENT ---
def run_elimination_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 3: ELIMINATION CUP")
    print("Testing: Bracket logic over TCP")
    print("=" * 50 + "\n")

    actions = [
        {"payload": {"command": "USER", "username": "ElimAdmin"}},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 1"}, "save_id": "e_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 2"}, "save_id": "e_t2"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 3"}, "save_id": "e_t3"},
        {"payload": {"command": "CREATE_TEAM", "name": "E-Team 4"}, "save_id": "e_t4"},

        {"payload": {"command": "CREATE_CUP", "cup_type": "ELIMINATION",
                     "team_ids": ["$e_t1", "$e_t2", "$e_t3", "$e_t4"]}, "save_id": "elim_id"},
        {"payload": {"command": "GET_STANDINGS", "id": "$elim_id"}}
    ]

    t = TestClient("ElimAdmin", actions)
    t.start();
    t.join()


# --- SCENARIO 4: GROUP STAGE TRANSITION ---
def run_group_transition_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 4: GROUP TO PLAYOFF TRANSITION")
    print("Testing: Playing all group games and triggering playoffs.")
    print("=" * 50 + "\n")

    # 1. Setup: Create 8 teams (Enough for 4 groups of 2)
    setup_actions = [{"payload": {"command": "USER", "username": "GroupAdmin"}}]

    team_ids = []
    # Create 8 teams so we get 2 teams per group (4 groups default) -> 1 game per group
    for i in range(1, 9):
        t_id = f"g_t{i}"
        setup_actions.append({
            "payload": {"command": "CREATE_TEAM", "name": f"G-Team {i}"},
            "save_id": t_id
        })
        team_ids.append(f"${t_id}")

    setup_actions.append({
        "payload": {"command": "CREATE_CUP", "cup_type": "GROUP", "team_ids": team_ids},
        "save_id": "group_cup"
    })

    # Run setup
    client = TestClient("Setup", setup_actions)
    client.start()
    client.join()

    # 2. Dynamic Play: Fetch games and play them all
    print("[Logic] Fetching group games to simulate matches...")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    s.sendall(json.dumps({"command": "GET_CUP_GAMES", "id": SHARED_CONTEXT["group_cup"]}).encode() + b"\n")
    s.makefile().readline()  # Skip info
    resp = json.loads(s.makefile().readline())
    game_ids = resp.get("game_ids", [])
    s.close()

    print(f"[Logic] Found {len(game_ids)} group games. Playing them now...")

    play_actions = [{"payload": {"command": "USER", "username": "Referee"}}]
    for gid in game_ids:
        play_actions.append({"payload": {"command": "START", "id": gid}})
        play_actions.append({"payload": {"command": "SCORE", "id": gid, "points": 3, "side": "HOME"}})
        # We rely on the internal logic that the game is 'played' enough for standings

    # 3. Trigger Playoffs
    play_actions.append({"wait": 1})
    play_actions.append({"payload": {"command": "GENERATE_PLAYOFFS", "id": "$group_cup"}})

    player = TestClient("Referee", play_actions)
    player.start()
    player.join()


# --- SCENARIO 5: PERSISTENCE CHECK ---
def run_persistence_scenario():
    print("\n" + "=" * 50)
    print("SCENARIO 5: PERSISTENCE & RECOVERY")
    print("Testing: Save state, (Simulated) Restart, Verify Data.")
    print("=" * 50 + "\n")

    # Step 1: Create Data (Teams AND a Game) and Save
    seed_actions = [
        {"payload": {"command": "USER", "username": "Saver"}},
        {"payload": {"command": "CREATE_TEAM", "name": "Persistent FC"}, "save_id": "p_t1"},
        {"payload": {"command": "CREATE_TEAM", "name": "Immutable Utd"}, "save_id": "p_t2"},
        # Create a Game, because Games are watchable
        {"payload": {"command": "CREATE_GAME", "home_id": "$p_t1", "away_id": "$p_t2"}, "save_id": "p_game"},
        {"payload": {"command": "SAVE"}}
    ]

    c1 = TestClient("Saver", seed_actions)
    c1.start()
    c1.join()

    print("\n   âš ï¸  ACTION REQUIRED: Restart the Server NOW to test persistence.")
    print("   âš ï¸  (Stop 'server.py', then run it again)")

    # --- FIX: Use input to wait indefinitely ---
    input("   âš ï¸  Press ENTER here once the server is back online >> ")

    # Step 2: Connect and Verify
    verify_actions = [
        {"payload": {"command": "USER", "username": "Verifier"}},
        {"payload": {"command": "WATCH", "id": "$p_game"}}
    ]

    c2 = TestClient("Verifier", verify_actions)
    c2.start()
    c2.join()

if __name__ == "__main__":
    run_concurrency_scenario()
    time.sleep(1)
    run_league_scenario()
    time.sleep(1)
    run_elimination_scenario()
    time.sleep(1)
    run_group_transition_scenario()
    time.sleep(1)
    run_persistence_scenario()
