import itertools
from typing import Any, Dict, List, Optional, Tuple

from cup import Cup
from game import Game
from team import Team


class Repo:
    """A repository for creating and managing domain objects like Teams and Games.

    This class acts as both a factory and a registry, abstracting away the
    details of object creation. It also manages object lifecycle by
    tracking "attachments" to prevent deletion of objects that are in use.
    """

    def __init__(self) -> None:
        """Initializes the repository with an empty object store."""
        self._objects: Dict[int, Dict[str, Any]] = {}
        # Using itertools.count is a memory-efficient way to generate endless
        # sequential IDs without needing to manually track the last ID.
        self._id_counter = itertools.count(start=1)

    def create(self, **kwargs: Any) -> int:
        """Creates and registers an object based on its 'type'.

        This factory method centralizes instantiation logic. It returns the
        unique ID assigned to the newly created object.
        """
        obj_type: Optional[str] = kwargs.pop("type", None)
        if obj_type is None:
            raise ValueError("You must specify an object 'type' to create.")

        new_id = next(self._id_counter)

        if obj_type == "team":
            new_obj = Team(**kwargs)
        elif obj_type == "game":
            # The Game constructor requires an ID, so we inject the one
            # generated by the repository.
            kwargs["id_"] = new_id
            new_obj = Game(**kwargs)
        elif obj_type == "cup":
            new_obj = Cup(**kwargs)
        else:
            raise ValueError(f"Unknown object type '{obj_type}'")

        self._objects[new_id] = {
            "instance": new_obj,
            "attachment_count": 0,
            "users": [],
        }
        return new_id

    def list(self) -> List[Tuple[int, str]]:
        """Returns a list of (ID, description) for all managed objects."""
        results: List[Tuple[int, str]] = []
        for id, data in self._objects.items():
            instance = data["instance"]
            description = str(instance)
            results.append((id, description))
        return results

    def listattached(self, user: str) -> List[Tuple[int, str]]:
        """Lists all objects that a specific user is attached to."""
        results: List[Tuple[int, str]] = []

        for obj_id, data in self._objects.items():
            if user in data["users"]:
                instance = data["instance"]
                description = str(instance)
                results.append((obj_id, description))
        return results

    def attach(self, id: int, user: str = "Polat Alemdar") -> Dict[str, Any]:
        """Attaches a user to an object, incrementing its attachment count."""
        self._objects[id]["attachment_count"] += 1
        self._objects[id]["users"].append(user)
        return self._objects[id]

    def detach(self, id: int, user: str) -> None:
        """Detaches a user from an object, decrementing its attachment count."""
        obj_data = self._objects[id]
        if user in obj_data["users"]:
            obj_data["users"].remove(user)
            if obj_data["attachment_count"] > 0:
                obj_data["attachment_count"] -= 1

    def delete(self, id: int) -> None:
        """Deletes an object, but only if it has no attachments.

        This safety mechanism prevents the accidental deletion of an object
        that is still in use.
        """
        if self._objects[id]["attachment_count"] > 0:
            raise ValueError(
                f"Cannot delete object {id}; it is still attached by {self._objects[id]['attachment_count']} user(s)."
            )
        else:
            del self._objects[id]
